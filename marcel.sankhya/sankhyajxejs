https://github.com/wansleynery/SankhyaJX

https://github.com/wansleynery/BI-SankhyaJS

https://github.com/wansleynery/SankhyaJX

# SankhyaJX

## Descrição

A classe `JX` é uma coleção de métodos estáticos para facilitar a manipulação de requisições HTTP, manipulação de dados de banco de dados, interação com páginas web e gerenciamento de parâmetros e cookies em aplicações web. Ela oferece funcionalidades como realizar requisições POST e GET, consultar dados de banco, salvar e deletar registros, manipular elementos de páginas web, entre outras.

---

## Instalação

A instalação pode ser feita baixando o arquivo `jx.js` (Homologação e Debug) ou `jx.min.js` (Produção) e importando-o no seu projeto. Por exemplo:

```html
<script src="jx.js"></script> <!-- Homologação e Debug -->
<script src="jx.min.js"></script> <!-- Produção -->

```

Contudo, a forma mais prática é pegar a ultima versão atualizada do arquivo direto do repositorio do GitHub, usando o cdn do [jsDelivr](https://www.jsdelivr.com/).
Obs.: A atualização do cache do CDN da jsDelivr pode demorar até 24 horas, ou seja, implementações recentes podem não estar disponíveis imediatamente.

```html
<script src="<https://cdn.jsdelivr.net/gh/wansleynery/SankhyaJX@main/jx.js>"></script>
<script src="<https://cdn.jsdelivr.net/gh/wansleynery/SankhyaJX@main/jx.min.js>"></script>

```

---

## Uso e Exemplos

### Banco de Dados

- **consultar(query)**: Realiza consultas SQL. Retorna uma promessa com os resultados da consulta.

```jsx
/* Consulta ao banco com resposta formatada em JS */
JX.consultar ('SELECT * FROM TGFMAR').then (console.log);

```

- **salvar(dados, instancia, chavesPrimarias)**: Salva registros no banco com a service auxiliar (`CRUDServiceProvider.saveRecord`). Aceita um objeto com os dados, o nome da tabela e as chaves primárias.

```jsx
/* Criar multiplos NOVOS registros (deixar as chaves primarias vazias) */
JX.salvar ({ DESCRICAO: 'Qualquer Marca' }, 'MarcaProduto', [{}, {}, {}]).then (console.log);

/* Atualizar multiplos registros (informar as chaves primarias de cada registro) */
/* Repare que, intencionalmente, estou forcando o erro em apenas um dos salvamentos, */
/* mas por nao ser blocante, ele continuara realizando os outros salvamentos com sucesso */
JX.salvar ({ DESCRICAO: 'Outro produto' }, 'MarcaProduto', [{ CODIGO: 'asd' }, { CODIGO: 9998 }, { CODIGO: 9999 }]).then (console.log);

```

- **novoSalvar(dados, instancia, chavesPrimarias)**: (BETA) Salva registros no banco com a service oficial das telas nativas (`DatasetSP.save`). Aceita um objeto com os dados, o nome da tabela e as chaves primárias.

```jsx
/* Criar multiplos NOVOS registros (deixar as chaves primarias vazias) */
JX.salvar ({ DESCRICAO: 'Qualquer Marca' }, 'MarcaProduto').then (console.log);

/* Atualizar multiplos registros (informar as chaves primarias de cada registro) */
/* Repare que, intencionalmente, estou forcando o erro em apenas um dos salvamentos, */
/* mas por nao ser blocante, ele continuara realizando os outros salvamentos com sucesso */
JX.salvar ({ DESCRICAO: 'Outro produto' }, 'MarcaProduto', { CODIGO: 'asd', OUTRA_PK: 9999 }).then (console.log);

```

- **deletar(instancia, chavesPrimarias)**: Deleta registros. Requer o nome da tabela e as chaves primárias dos registros a serem excluídos.

```jsx
/* Apaga multiplos registros (informar as chaves primarias de cada registro) */
/* O primeiro registro nao existe (PK 9997), o que gerarara um erro nessa requisicao */
/* mas por nao ser blocante, ele continuara realizando as outras delecoes com sucesso */
JX.deletar ('MarcaProduto', [{ CODIGO: 9997 }, { CODIGO: 9998 }, { CODIGO: 9999 }]).then (console.log);

```

### Manipulação de Página

- **acionarBotao(parametros, configuracoes)**: Aciona botões de ação remotamente. Parâmetros incluem os dados do botão e as configurações como tipo e ID.

```jsx
JX.acionarBotao (
    {
        PARAMETRO_A: 'Valor',
        Parametro_B: 'false',    // Enviar valores booleanos como string
        pARameTRo_c: 2           // Validar o nome do parametro a ser recebido
    },
    {
        tipo         : 'JS',         // Tipo do botao de acao (JS, JAVA e SQL)
        idBotao      : 30,           // ID do botao de acao (JS, JAVA e SQL)
        entidade     : 'TELA_TAL',   // Nome da Entidade que possui o botao de acao (apenas SQL)
        nomeProcedure: 'AD_PROC_TAL' // Nome da Procedure a ser executada (apenas SQL)
    }
).then (console.log);

```

- **removerFrame(configuracoes)**: Remove o frame de uma página de BI. Configurações incluem a instância e a página inicial.

```jsx
JX.removerFrame ({ instancia: 'TELA_HTML5', paginaInicial: 'paginas/entidade/index.jsp' });

```

- **novaGuia(forcado)**: Abre a página atual em uma nova aba. Opcionalmente, pode forçar a abertura da nova aba mesmo em contextos restritos.

```jsx
JX.novaGuia ();

```

- **abrirPagina(resourceID, chavesPrimarias)**: Abre uma página específica dentro do sistema, usando o ID do recurso e as chaves primárias para localização.

```jsx
JX.abrirPagina ('br.com.sankhya.core.cad.marcas', { CODIGO: 999 });

```

- **fecharPagina()**: Fecha a página atual. Útil em contextos onde a página está integrada a um sistema maior.

```jsx
JX.fecharPagina ();

```

### Retorno de Valores

- **getUrl(path)**: Retorna a URL atual da página, permitindo adicionar um caminho específico se necessário.

```jsx
/* Busca a URL origem (URL base) do local atual */
console.log (JX.getUrl ())                                      // <http://localhost/mge>
console.log (JX.getUrl ('js/dashboardGrid/dashboardGrid.css')); // <http://localhost/mge/js/dashboardGrid/dashboardGrid.css>

```

- **getCookie(nome)**: Retorna o valor de um cookie especificado pelo nome.

```jsx
/* Busca do conteudo de um cookie */
let valorCookie = JX.getCookie ('nomeCookie');
console.log (valorCookie);

```

- **getArquivo(caminhoArquivo)**: Busca o conteúdo de um arquivo localizado no caminho especificado.

```jsx
/* Busca do conteudo de arquivos internos */
JX.getArquivo ('/caminho/do/arquivo.txt')
   .then (conteudo => console.log (conteudo))
   .catch (erro => console.error (erro));

```

- **getParametro(nomesParametros)**: Retorna valores de parâmetros específicos, baseados em seus nomes ou chaves.

```jsx
// {PERCSTCAT137SP: 90, mgearmazem.gerar.nf.impureza.codImpureza: 0, BASESNKPADRAO: 'IkRBVEFDUklBQ0FPOjA0LzA1LzIwMjMuQkFTRTpQQURSQU8uQkFOQ086T1JBQ0xFIg==', ASD: null}
JX.getParametro (['PERCSTCAT137SP', 'mgearmazem.gerar.nf.impureza.codImpureza', 'BASESNKPADRAO', 'ASD']).then (console.log);

// {123: null}
JX.getParametro ('123').then (console.log);

// {BALANCASP2600R: false, BL-SBR140-RS232: false, BALANCASATURNO: false, MODELOCPASEMENT: 0, TOPSCPASEMENTE: null, …}
JX.getParametro ().then (console.log);

// ERRO: Forneça o nome dos parametros a serem buscados como Texto ou Array de Textos!
JX.getParametro (5).then (console.log);

// ERRO: Os parametros informados devem ser Textos não vazios!
JX.getParametro (['']).then (console.log);

// ERRO: Os parametros informados devem ser Textos não vazios!
JX.getParametro (['ASD', 7]).then (console.log);

// ERRO: Forneça o nome dos parametros a serem buscados como Texto ou Array de Textos!
JX.getParametro (false).then (console.log);

```

### Chamada de Serviço

- **chamarServico(nomeServico, dados, dadosAdicionais)**: Permite a chamada de serviços web específicos, facilitando a interação com diferentes módulos e funcionalidades do sistema.

```jsx
JX.chamarServico ("mgecom@admin.getVersao").then (console.log); // Sem corpo de envio
JX.chamarServico ('WorkspaceSP.getStartupData', '<serviceRequest serviceName="WorkspaceSP.getStartupData"><requestBody><resourceIDs/><clientEventList/></requestBody></serviceRequest>');

```

---

## Considerações

- Muitos métodos da `JX` são assíncronos e retornam `Promises`.
- Implemente tratamento de erros para assegurar a robustez da aplicação.
- A biblioteca `JX` é desenhada para ser versátil e fácil de usar, adequada para uma variedade de cenários em aplicações web.

# SankhyaJS BI MasterBlaster Turbo Super HyperUltra MegaPower 3000

Finalmente...!

## Briefing

Este é um projeto que torna a biblioteca SankhyaJS e seus componentes em AngularJS disponíveis para uso em um componente de BI.
Por quê? ...porque sim!

## Instalação

1. Primeiro, clone o repositório e entre no diretório:

```bash
git clone <https://github.com/wansleynery/BI-SankhyaJS.git>
cd BI-SankhyaJS

```

1. Depois, MANUALMENTE, crie um ZIP com o conteúdo do diretório raiz (ou use um comando caso esteja no Linux):

```bash
zip -r dashboard.zip .

```

1. Abra a tela Construtor de Componentes do BI e importe o arquivo ZIP criado dentro de um novo componente do tipo "HTML5" e dê o nome do componente de **TELA_HTML5** (importante para remoção do frame nas controladoras - linha 24).
2. Defina como a página a ser aberta algum dos dois arquivos JSP disponíveis na pasta *entidade* ou *standalone*.
3. Pronto! Agora é só clicar em pré-visualizar a tela.

## Desenvolvimento (Pontos de atenção)

1. A estrutura do arquivo JSP deverá ser mantida (como está) na sua maior parte. Após exaustivas tentativas, testes, implementações e correções, a modelagem atual (incluindo a ordem das tags e conteudos) está funcional. **Qualquer alteração poderá causar problemas de renderização e processamento.**

---

1. As importações de arquivos acessórios para o funcionamento da tela deverá seguir as localizações específicas nos arquivos JSP:
    - CSS: Linha 34
    - JS (Bibliotecas): Linha 181
    - JS (Controladoras): Linha 230
    - JS (Services): Linha 235

---

1. Ambas as controladoras fazem uso de um recurso da biblioteca *JX* chamado `removerFrame` que, basicamente, remove o frame de entorno do componente de BI. Isso pode ser bom para a estética da tela e ganho pequeno de espaço, por outro lado, perderemos a barra de parâmetros lateral e o botão de recarga e maximização do componente. Tenha isso em mente se deseja mesmo esse comportamento e, se necessário, remova as linhas entre 14 a 26 na respectiva controladora que estiver utilizando.

---

1. **Nem todas as preferências podem funcionar** se buscadas pela chamada `MGEParameters.as...`, tendo em vista que é necessário a injeção das dependências ainda na construção da página e isso inclui as preferências que o *ResourceID* da tela pode acessar em tempo de execução. Como uma forma de contornar isso, utilize um método de consulta ao banco de forma assíncrona (para o exemplo, utilizo a biblioteca importada do JX):

```jsx
//...

    JX.consultar (`
        SELECT COALESCE (MAX (INTEIRO), -1) AS INTEIRO
          FROM TSIPAR
         WHERE CHAVE = 'CODUSUVISITA'
           AND CODUSU = 0
    `).then (parametros => {

        // Sempre retornara um array, sendo vazio caso nao encontre
        // Exemplo: [{ INTEIRO: 0 }, { INTEIRO: 1 }, ...]

        for (let parametro of parametros) {
            console.log (parametro.INTEIRO);
        }

    });

//...

```

---

1. Essa versão de tela é desenvolvida para controladora sendo uma classe, mas as telas do Sankhya são desenvolvidas em modelagem funcional ou seja, a controladora é uma função com escopo disassociado, por isso é usado a abordagem seguinte nos códigos Sankhya (dessa forma, o contexto da função passa a ser controlado sem efeitos colaterais, uma forma segura de se trabalhar com o AngularJS):

```jsx
//...
    var self = this;
    self.variavel = 'valor';
//...

```

Mas as controladoras desse projeto,  estão implementadas como classe, para controlar melhor o escopo e gerenciar o contexto da forma mais estrita possível, sem contar que mostro uma forma mais clara e conscisa de trabalhar com classes dentro do AngularJS:

```jsx
//...
    this.variavel = 'valor';
//...

```

*Sinta-se a vontade para alterar isso!*

---

1. No exemplo da pasta *entidade*, utilizamos um componente da biblioteca SankhyaJS chamado `sk-dynaform`, que *"monta"* a grade e o formulário de forma automatica, mas ele só poderá ser utilizado com uma entidade existente (ou um *dataset* existente, mas ainda não testado), ou seja, precisa indicar uma tabela ou view real do Sankhya para a construção do componente, seguindo a respectiva ordem e hierarquia:

```html
<sk-application> <!-- Componente que cria um contexto de aplicação para os componentes -->

    <sk-dynaform></sk-dynaform> <!-- Componente que pre-monta um formulário a partir de uma entidade -->

</sk-application>

```

Agora, na pasta *standalone*, terá um exemplo de como montar uma grade ou formulário de forma dinâmica, a partir de dados temporários ou que não estejam em lugar algum da plataforma, com os componentes principais sendo o `sk-dataset` e `sk-datagrid`, seguindo a respectiva ordem e hierarquia (Observação: pode ser utilizado essa modelagem para montar telas com entidades existentes, bastando remover o parâmetro `sk-standalone` do componente `sk-dataset`):

```html
<sk-application> <!-- Componente que cria um contexto de aplicação para os componentes -->

    <sk-dataset sk-standalone></sk-dataset> <!-- Componente que cria um estrutura de dados em memória para ser utilizada como fonte de dados -->

    <sk-double-face-panel> <!-- Componente GRADE-FORMULÁRIO que permite a troca de visão entre dois lados, como um cartão -->

        <sk-face-one> <!-- O lado A do componente GRADE-FORMULÁRIO, geralmente para o formulário -->

            <sk-form></sk-form> <!-- Componente que pré-monta um formulário a partir dos dados do dataset -->

            <!-- ... OU ... -->

            <sk-simple-form></sk-simple-form> <!-- Componente que pré-monta um formulário a partir dos dados do dataset -->

        </sk-face-one>

        <sk-face-two> <!-- O lado B do componente GRADE-FORMULÁRIO -->
            <sk-datagrid> <!-- Componente de grade, que consome a fonte de dados do dataset -->
            </sk-datagrid>
        </sk-face-two>

    </sk-double-face-panel>

</sk-application>

```

## Licença

Toda, pode passar!

Brincadeiras a parte, o projeto é licenciado sob a licença MIT. Um dos pontos principais de atenção é que, mesmo sendo um projeto de código aberto, não deverá ser inputado qualquer responsabilidade ao autor original por danos causados pelo uso do código ou mesmo a necessidade de manutenção do mesmo.
